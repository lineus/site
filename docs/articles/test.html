<!DOCTYPE html>
<html lang="en">

  <head>
    <title>lineus.dev test</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/style/index.css">
  </head>

  <body>
    <div id="header">
      <div id="logo"><a id="name" href="/">lineus</a></div>
      <div id="nav"><a class="navlink" id="whoami" href="/whoami.html" title="about">About</a><a class="navlink" id="ls" href="/ls.html" title="list articles">Articles</a><a class="navlink" id="projects" href="/projects.html" title="projects">Projects</a><span id="searchBut">Search</span></div>
      <script>
        (function() {
          const {
            location
          } = window;
          const path = `${location}`.split('/');
          const file = path[path.length - 1];
          const navs = Array.from(document.querySelectorAll('#nav a'));
          let active = navs.findIndex(el => el.getAttribute('href') === `/${file}`);
          navs.map(n => n.classList.remove('active'));
          if (active >= 0) {
            navs[active].classList.add('active')
          }
        })()
        //- a#grep(href="/grep.html" class="navlink" title="search Articles") Search
      </script>
    </div>
    <div id="searchBox">
      <div class="qbef">Query</div>
      <div class="arrow rt270"></div><input class="query" type="text" autocapitalize="none">
      <div class="qaft">Results</div>
      <div class="arrow downByHalf"></div>
    </div>
    <div id="results">
      <script>
        'use strict';

        if (typeof exports !== 'undefined') {
          module.exports = {
            searchFactory
          };
        }

        function searchFactory(searchData) {
          if (!searchData) {
            throw new Error('SearchFactoryRequiresDataError');
          }

          return new go();

          function go() {
            this.data = searchData;
            this.result = [];
            const search = (query) => {
              if (!query) {
                return this.data.map(f => f.path);
              }
              const hasLevelSpecifier = /[\w]+:[\w]+/.test(query);
              const queryTokens = query.split(' ');
              const forThese = [];
              if (hasLevelSpecifier) {
                const validLS = ['filename', 'tags', 'headers', 'links'];
                queryTokens.map(q => {
                  if (/[\w]+:[\w]+/.test(q)) {
                    const [token, qString] = q.split(':');
                    if (!validLS.includes(token)) {
                      throw new Error(`InvalidQueryTokenError: ${token}`);
                    }
                    forThese.push({
                      token,
                      qString
                    });
                  } else {
                    forThese.push({
                      token: 'all',
                      qString: q
                    });
                  }
                });
              } else {
                queryTokens.map(q => {
                  forThese.push({
                    token: 'all',
                    qString: q
                  });
                });
              }

              const allSearch = (q) => {
                let re = new RegExp(`.*${q}.*`);
                this.data.map(f => {
                  for (let i = 0; i < 6; i++) {
                    let index = f.level[i].tokens.findIndex(matches);
                    if (index > -1) {
                      this.result.push({
                        level: i,
                        path: f.path
                      });
                    }
                  }
                });

                function matches(el) {
                  return re.test(el);
                }
              };

              const fSearch = (q) => {
                let re = new RegExp(`.*${q}.*`);
                this.data.map(f => {
                  let index = f.level[0].tokens.findIndex(matches);
                  if (index > -1) {
                    this.result.push({
                      level: 0,
                      path: f.path
                    });
                  }
                });

                function matches(el) {
                  return re.test(el);
                }
              };

              const tSearch = (q) => {
                let re = new RegExp(`.*${q}.*`);
                this.data.map(f => {
                  let index = f.level[1].tokens.findIndex(matches);
                  if (index > -1) {
                    this.result.push({
                      level: 1,
                      path: f.path
                    });
                  }
                });

                function matches(el) {
                  return re.test(el);
                }
              };

              const hSearch = (q) => {
                let re = new RegExp(`.*${q}.*`);
                this.data.map(f => {
                  for (let i = 2; i < 5; i++) {
                    let index = f.level[i].tokens.findIndex(matches);
                    if (index > -1) {
                      this.result.push({
                        level: i,
                        path: f.path
                      });
                    }
                  }
                });

                function matches(el) {
                  return re.test(el);
                }
              };

              const lSearch = (q) => {
                let re = new RegExp(`.*${q}.*`);
                this.data.map(f => {
                  let index = f.level[5].tokens.findIndex(matches);
                  if (index > -1) {
                    this.result.push({
                      level: 5,
                      path: f.path
                    });
                  }
                });

                function matches(el) {
                  return re.test(el);
                }
              };

              forThese.map(o => {
                switch (o.token) {
                  case 'all':
                    allSearch(o.qString);
                    break;
                  case 'filename':
                    fSearch(o.qString);
                    break;
                  case 'tags':
                    tSearch(o.qString);
                    break;
                  case 'headers':
                    hSearch(o.qString);
                    break;
                  case 'links':
                    lSearch(o.qString);
                    break;
                  default:
                    throw new Error('InvalidQueryTokenError');
                }
              });

              let temp = [...this.result];
              this.result = [];
              return temp;

            };

            return search;
          }
        }
      </script>
      <script>
        const searchButton = document.querySelector('#searchBut');
        const query = document.querySelector('input.query');
        const searchBox = document.querySelector('#searchBox');
        const results = document.querySelector('#results');
        const header = document.querySelector('#header');
        const queryLogos = Array.from(document.querySelectorAll('.qbef, .qaft, .qaf2, .arrow'));
        let searchFN;
        window.fetch('/search.json').then(res => {
          return res.json()
        }).then(json => {
          searchFN = searchFactory(json);

          function handler(e) {
            results.innerHTML = '';
            let searchRes = [];
            searchRes = searchFN(query.value.trim())
            results.innerHTML = searchRes.map(r => {
              if (typeof r === 'string') {
                return `
            <a href=${r}>
            ${
              r.replace(/.*\/([^/]+)$/, '$1')
               .replace(/_/g, ' ')
               .replace(/\.html$/, '')
               }
            </a>`
              } else {
                return `
            <a href=${r.path}>
            ${
              r.path.replace(/.*\/([^/]+)$/, '$1')
                .replace(/_/g, ' ')
                .replace(/\.html$/, '')
             }
            </a>`
              }
            }).join('\n')
          }
          const search = debounce(handler, 500)
          query.addEventListener('keyup', search);
          searchButton.addEventListener('click', function() {
            if (searchBox.style.height !== '3em') {
              queryLogos.map(l => l.style.opacity = '1');
              query.style.height = '2em';
              query.style.width = '60vw';
              searchBox.style.height = '3em';
              results.innerHTML = searchFN().map(r => {
                return `
            <a href=${r}>
              ${
                r.replace(/.*\/([^/]+)$/, '$1')
                  .replace(/_/g, ' ')
                  .replace(/\.html$/, '')
                  }
            </a>`;
              }).join('\n')
              results.style.height = `80vh`;
            } else {
              queryLogos.map(l => l.style.opacity = '0');
              searchBox.style.height = '0px';
              query.style.height = '0px';
              query.style.width = '100vw';
              results.innerHTML = '';
              results.style.height = '0px';
            }
          });
        }).catch(console.error)

        function debounce(func, wait, immediate) {
          var timeout;
          return function() {
            var context = this,
              args = arguments;
            var later = function() {
              timeout = null;
              if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
          };
        };
      </script>
    </div>
    <div id="container">
      <h1 id="my-first-test-article">My First Test article</h1>

      <p>You can do it, ra ra ra.</p>


      <p>I wonder if I can actually finish this? I think maybe. I need to be clear about what I like and don&#39;t like about it, so that it evolves into something better.</p>
      <h2 id="will-it-work">Will it work?</h2>
      <p>Only if I am clear about a direction and the steps that I need to take to make it worth the time.</p>
      <h3 id="who-knows">Who Knows?</h3>
      <p>Not me. Not my dogs, that&#39;s for sure. They don&#39;t know shit.</p>
      <!-- 
  This is a Comment.
-->






    </div>
    <script src="https://s3.amazonaws.com/stitch-sdks/js/bundles/4.4.0/stitch.js"></script>
    <script>
      const link = './docs/articles/test.html';
      const client = stitch.Stitch.initializeDefaultAppClient('blog-iydtx');
      const db = client.getServiceClient(stitch.RemoteMongoClient.factory, 'mongodb-atlas').db('SiteMetrics');
      client.auth.loginWithCredential(new stitch.AnonymousCredential()).then(function(user) {
        db.collection('visitors').insertOne({
          path: link
        }).catch(console.dir);
      }).catch(console.dir);
    </script>
    <div id="footer">
      <div id="rss"><a href="https://lineus.dev/articles.xml">Subscribe</a></div>
      <link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/dKDB8Y9Vz"><img src="https://bmc-cdn.nyc3.digitaloceanspaces.com/BMC-button-images/BMC-btn-logo.svg" alt="Buy me a coffee"><span style="margin-left:5px">Buy me a coffee</span></a>
    </div>
  </body>

</html>